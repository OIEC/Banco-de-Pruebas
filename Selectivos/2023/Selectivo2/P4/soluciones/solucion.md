Nuestra primera idea basada en casos particulares es la hipótesis que restar siempre el dígito mayor nos llevará más rápido al valor de 0. No entraremos a detalle en la demostración, pero es posible probar que esto se cumple para todos los valores de $n_i$ considerados en el problema. Nuestra primera solución será restar el primer dígito repetitivamente hasta llegar a 0 e imprimir la cantidad de pasos que esto lleve. Invocamos este método para cada $n_i$ de la entrada. Hallar el mayor dígito de un número lleva $O(\log n_i)$, ya que debemos iterar sobre todos los dígitos y la cantidad de dígitos es $O(\log n_i)$. Dado que en cada paso el número se reduce en a lo mucho 9, la cantidad de veces que repetimos esto es $O(n_i / 9) = O(n_i)$. Por lo tanto para un $n_i$, el proceso lleva $O(n_i \log n_i)$. En el peor de los casos $i = 1, 2, ..., N$, por lo que la complejidad total sería $O(N^2 \log N)$ con espacio adicional de O(1) ya que no utilizamos ninguna estructura adicional. Esta solución nos permite resolver la primera subtarea.

Ya que en el peor de los casos debemos resolver el problema para todos los valores entre 1 y $N$, esto nos indica que quizá podemos reutilizar las respuestas de $k$ más pequeños para computar la respuesta de un valor mayor. Esta estructura de subproblemas más pequeños nos guía a una solución de programación dinámica. Si $f(k)$ es la menor cantidad de pasos y consideramos $k_i$ como los dígitos de $k$, entonces $f(k)$ es 1 + el mínimo entre $f(k - k_i)$ entre todos los dígitos $k_i$. En otras palabras, si restamos cada dígito de $k$, tomamos el dígito que nos de la menor cantidad de pasos.
Ya que los dígitos están entre 0 y 9, hay a lo mucho 10 valores distintos para $f(k - k_i)$. Esto indica que cada $f(k)$ necesita a lo mucho los 9 valores (excluyendo el dígito 0) anteriores para ser calculado.
Si calculamos $f(1), f(2), ..., f(9)$ podemos calcular todos los valores iterativamente con la fórmula anterior. Consideremos $T$ el mayor valor posible de $n_i$. Esta solución tiene como propiedad que necesita calcular las respuestas para todos los valores menores a $T$ en un arreglo. Por lo tanto podemos resolver el problema para $T$ y simplemente imprimir las respuestas para cada uno de los $n_i$ sin ningún costo adicional de tiempo. En cada paso debemos iterar sobre todos los dígitos de $k$, lo que nos lleva $O(\log k)$ para cada $1 \leq k \leq T$. En total esto nos llevaría $O(T \log T)$. Iterar sobre cada $n_i$ en el peor de los casos es $O(N)$ por lo que en total tendríamos $O(T \log T) + O(N)$ de tiempo con $O(T)$ espacio adicional, ya que guardamos las $N$ respuestas en un arreglo. Con esta solución resolvemos las dos subtareas.

Adicionalmente, podemos resolver el problema combinando las ideas de ambas soluciones. Usando la técnica del dígito mayor, podemos guardar todos los valores en un arreglo. Es decir, si $k$ es el dígito mayor de $n_i$, tenemos que $f(n_i) = 1 + f(n_i - k)$. Si tenemos la respuesta guardada para $n_i - k$, la respuesta para $n_i$ se calcula en tiempo constante luego de hallar el dígito mayor, que toma $O(\log n_i)$. Podemos entonces iterativamente calcular cada respuesta en base a una de las 9 respuestas anteriores que están en el arreglo. Ya que en el peor de los casos $1 \leq i \leq N$, obtenemos una complejidad de $O(T \log T)$ en tiempo y $O(T)$ espacio adicional.

