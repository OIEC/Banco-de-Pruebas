# Solución

La primera idea por fuerza bruta es multiplicar las matrices de todas las formas posibles. Si empezamos con una cadena de `N` matrices, podemos ubicar el primer conjunto de paréntesis de `N-1` formas. En cierta forma, estamos delimitando cual será la última multiplicación a realizarse. Por ejemplo, con cuatro matrices hay tres formas de poner los primeros paréntesis (última operación): `(A)(BCD)`, `(AB)(CD)` y `(ABC)(D)`. Por lo tanto, el mínimo número de multiplicaciones a realizar es el mínimo entre estas `N-1` posibilidades, por lo que el problema tiene la propiedad de las subestructuras óptima. De aquí se resuelve el problema recursivamente en cada posibilidad:
Digamos que las dimensiones de las matrices se encuentran consecutivamente en un arreglo `dp`. Entonces podemos expresar el mínimo `C` de la siguiente forma. Si `i` y `j` son el inicio y el final de la matriz considerada, podemos poner la división de la operación en cualquier índice `i \leq k \leq j`:

`\min_{k} {C(p, i, k) + C(p, k + 1, j) + p[i - 1] * p[k] * p[j] }`

Una solución recursiva es claramente exponencial. La idea para aprovecharnos de los subproblemas repetidos encontrados, es usar programación dinámica. Podemos usar un arreglo bidimensional donde cada entrada `dp[i][j]` represente el mínimo número de operaciones de las matrices en la cadena desde el índice `i` al índice `j`. Podemos resolver el problema usando la misma fórmula descrita arriba, pero guardando los valores en ese arreglo y resolviendo el problema para todos los pares de índices `i,j`. La respuesta se encontrará en la entrada `dp[1][n]` al final de procesar todos los pares de índices. Notemos también que esta solución indirectamente también da el orden en el que se deben llevar las operaciones, se puede ir guardando el camino del `k` que se va escogiendo a cada nivel (la subdivisión de los paréntesis).
Ya que resolver el problema para cada par de índices `i,j` conlleva iterar sobre el rango entre ellos para cada subdivisión `k`, la complejidad de tiempo es cúbica, o `O(N^3)` y el espacio auxiliar es cuadrático `O(N^2)`. Hay formas más óptimas de resolver este problema en general. Sin embargo, para este en particular, el usar programación dinámica para optimizar la complejidad de tiempo usando espacio extra era suficiente.